# Multi Operations

While normally operations run in sequence, operations can also run in parallel, and you can control their order by specifying which operations run first and which depend on others, all through the use of the execution context.

The `execution` key is what enables this to work, while the `group` and `depends_on` properties make this functionality possible.

```json
"execution": {
  "group": "string",
  "depends_on": ["op-id-1", "op-id-2"]
}
```

- `group`
    
    Groups act as stages, and the manager only runs one stage at a time. The order of stages is determined by the first time a group appears in the operations array. Within a stage, any operation whose dependencies are already satisfied can run in parallel with others. A stage does not finish until every operation in it has either completed successfully or been marked as failed. Only when that stage is finished will the manager advance to the next one.
    
- `depends_on`
    
    List of operation `id`s this operation must wait for. Once every dependency is "ready," this operation is eligible to start.
    
    An operation or dependency can be "ready" when it has reached the "running" state (if no health check is specified). If it declares health checks, at least one successful health check cycle must have completed.
    Operations can only depend on other operations that are in the **same group (stage)**.
    
    So if `nginx-1` has an HTTP health check, `nginx-2` that depends on `nginx-1` won't start until `nginx-1` is up and healthy, not just created.
    

## Example

- `nginx-1` and `nginx-2` are in the same group `run1`. `nginx-2` depends on `nginx-1`, so `nginx-2` will wait for `nginx-1` to be healthy.
- `nginx-3` is in group `run2`. It will not start until the entire `run1` group is done.

```json
{
  "version": "0.1",
  "type": "container",
  "meta": {
    "trigger": "cli"
  },
  "ops": [
    {
      "type": "container/run",
      "id": "nginx-1",
      "args": {
        "cmd": [],
        "image": "nginx",
        "expose": [ 
          { 
            "port": 80, 
            "health_checks": [
              {
                "type": "http",
                "path": "/",
                "method": "GET",
                "expected_status": 200,
                "continuous": true
              }
            ] 
          }
        ]
      },
      "execution": {
        "group": "run1"
      }
    },
        {
      "type": "container/run",
      "id": "nginx-2",
      "args": {
        "cmd": [],
        "image": "nginx",
        "expose": [ 
          { 
            "port": 80, 
            "health_checks": [
              {
                "type": "http",
                "path": "/",
                "method": "GET",
                "expected_status": 200,
                "continuous": true
              }
            ] 
          }
        ]
      },
      "execution": {
        "group": "run1",
        "depends_on": ["nginx-1"]
      }
    },
            {
      "type": "container/run",
      "id": "nginx-3",
      "args": {
        "cmd": [],
        "image": "nginx",
        "expose": [ 
          { 
            "port": 80, 
            "health_checks": [
              {
                "type": "http",
                "path": "/",
                "method": "GET",
                "expected_status": 200,
                "continuous": true
              }
            ] 
          }
        ]
      },
      "execution": {
        "group": "run2",
        "depends_on": []
      }
    }
  ]
}

```

# Restart and Stop

The Node API provides endpoints that let you stop or restart at both the op level and the group level.

Stopping an operation means the scheduler tells only that operation to exit. Once it is stopped, the operation itself is marked as stopped, but its dependencies are unaffected. Any operations that depend on it will never be satisfied and remain blocked. Stopping a single operation does not advance the stage; the stage finishes when all its operations are either complete, stopped, or blocked.

Restarting an operation is a targeted stop followed by a clean relaunch of that same operation. Its dependencies are checked again; if they are ready, the operation starts immediately, otherwise it waits in pending until they are. Other operations in the stage are unaffected.

Stopping a group ends the entire stage. All running or pending operations in that group are stopped, and no new ones will start. Depending on policy, the job may halt after this, or it may advance to the next stage with the stopped stage marked as terminated.

Restarting a group resets the whole stage. Every operation in the group is stopped, its state is cleared, and then the stage is run again from the beginning. Dependencies are recalculated, and eligible operations launch in parallel just like on the first run.

```jsx
https://{{node}}.node.k8s.prd.nos.ci/job/{{job}}/ops (GET)
{
    "nginx-1": "running",
    "nginx-2": "running",
    "nginx-3": "pending"
}

https://{{node}}.node.k8s.prd.nos.ci/job/{{job}}/group/{{group}}/stop
https://{{node}}.node.k8s.prd.nos.ci/job/{{job}}/group/{{group}}/operation/{{opid}}/stop

https://{{node}}.node.k8s.prd.nos.ci/job/{{job}}/group/{{group}}/restart
https://{{node}}.node.k8s.prd.nos.ci/job/{{job}}/group/{{group}}/operation/{{opid}}/restart
```